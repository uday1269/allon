Program 1 : caser cipher
 

#include <stdio.h>
#include <string.h>
int main() {
    char text[100];
    int i, key;
    printf("Enter a message: ");
    fgets(text, sizeof(text), stdin);
    size_t len = strlen(text);
    if (text[len - 1] == '\n') {
        text[len - 1] = '\0';
    }
    printf("Enter key (1-25): ");
    scanf("%d", &key);

    for (i = 0; text[i] != '\0'; i++) {
        char ch = text[i];

        if (ch >= 'A' && ch <= 'Z') {
            ch = ((ch - 'A' + key) % 26) + 'A';
        } else if (ch >= 'a' && ch <= 'z') {
            ch = ((ch - 'a' + key) % 26) + 'a';
        }

        text[i] = ch;
    }

    printf("Encrypted message: %s\n", text);

    return 0;
}

Program 2 : 2. Write a C program for monoalphabetic substitution cipher maps a plaintext alphabet to a ciphertext
alphabet, so that each letter of the plaintext alphabet maps to a single unique letter of the ciphertext
alphabet

#code:

#include <stdio.h>
void encrypt(char *plaintext, char *ciphertext) {
    char *cipher = "QWERTYUIOPASDFGHJKLZXCVBNM";
    int i;
    for (i = 0; plaintext[i] != '\0'; i++) {
        char ch = plaintext[i];
        if (ch >= 'a' && ch <= 'z') {
            ch = ch - 'a' + 'A'; 
        }
        if (ch >= 'A' && ch <= 'Z') {
            int index = ch - 'A';
            ciphertext[i] = cipher[index];
        } else {
            ciphertext[i] = ch;
        }
    }
    ciphertext[i] = '\0';
}
int main() {
    char plaintext[100], ciphertext[100];
    printf("Enter plaintext (no spaces): ");
    scanf("%s", plaintext); 
    encrypt(plaintext, ciphertext);
    printf("Ciphertext: %s\n", ciphertext);

    return 0;
}

Program :3. Write a C program for Playfair algorithm is based on the use of a 5 X 5 matrix of letters constructed
using a keyword. Plaintext is encrypted two letters at a time using this matrix.

CODE : 

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define SIZE 5

void buildMatrix(char key[], char matrix[SIZE][SIZE]) {
    int used[26] = {0};
    used['J' - 'A'] = 1; // I/J combined

    int k = 0, i, j;
    char filteredKey[25];

    for (i = 0; key[i]; i++) {
        char c = toupper(key[i]);
        if (c == 'J') c = 'I';
        if (c < 'A' || c > 'Z') continue;
        if (!used[c - 'A']) {
            filteredKey[k++] = c;
            used[c - 'A'] = 1;
        }
    }

    int idx = 0;
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            if (idx < k) matrix[i][j] = filteredKey[idx++];
            else {
                for (char c = 'A'; c <= 'Z'; c++) {
                    if (!used[c - 'A']) {
                        matrix[i][j] = c;
                        used[c - 'A'] = 1;
                        break;
                    }
                }
            }
        }
    }
}

void findPos(char matrix[SIZE][SIZE], char c, int *r, int *col) {
    if (c == 'J') c = 'I';
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            if (matrix[i][j] == c) {
                *r = i; *col = j;
                return;
            }
}

void prepareText(char *text, char *out) {
    int i, j = 0;
    for (i = 0; text[i]; i++) {
        if (isalpha(text[i])) {
            out[j++] = toupper(text[i]) == 'J' ? 'I' : toupper(text[i]);
        }
    }
    if (j % 2 != 0) out[j++] = 'X'; // pad if odd length
    out[j] = '\0';
}

void encryptPair(char matrix[SIZE][SIZE], char a, char b, char *ea, char *eb) {
    int r1, c1, r2, c2;
    findPos(matrix, a, &r1, &c1);
    findPos(matrix, b, &r2, &c2);

    if (r1 == r2) { // same row
        *ea = matrix[r1][(c1 + 1) % SIZE];
        *eb = matrix[r2][(c2 + 1) % SIZE];
    } else if (c1 == c2) { // same column
        *ea = matrix[(r1 + 1) % SIZE][c1];
        *eb = matrix[(r2 + 1) % SIZE][c2];
    } else { // rectangle swap columns
        *ea = matrix[r1][c2];
        *eb = matrix[r2][c1];
    }
}

int main() {
    char key[100], plaintext[1000], prepared[1000], ciphertext[1000];
    char matrix[SIZE][SIZE];

    printf("Enter keyword: ");
    fgets(key, sizeof(key), stdin);
    key[strcspn(key, "\n")] = 0;

    buildMatrix(key, matrix);

    printf("\nPlayfair Matrix:\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++)
            printf("%c ", matrix[i][j]);
        printf("\n");
    }

    printf("\nEnter plaintext: ");
    fgets(plaintext, sizeof(plaintext), stdin);
    plaintext[strcspn(plaintext, "\n")] = 0;

    prepareText(plaintext, prepared);

    int len = strlen(prepared);
    for (int i = 0; i < len; i += 2) {
        encryptPair(matrix, prepared[i], prepared[i+1], &ciphertext[i], &ciphertext[i+1]);
    }
    ciphertext[len] = '\0';

    printf("\nCiphertext: %s\n", ciphertext);

    return 0;
}

Program 4. Write a C program for polyalphabetic substitution cipher uses a separate monoalphabetic substitution
cipher for each successive letter of plaintext, depending on a key.

CODE : 

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define ALPHABET_SIZE 26

char shiftChar(char c, int shift) {
    if (!isalpha(c)) return c;
    c = toupper(c);
    return (char)((((c - 'A') + shift) % ALPHABET_SIZE) + 'A');
}


void encrypt(const char *plaintext, const char *key, char *ciphertext) {
    int keyLen = strlen(key);
    int keyIndex = 0;

    for (int i = 0; plaintext[i] != '\0'; i++) {
        char p = plaintext[i];
        if (isalpha(p)) {
            int shift = toupper(key[keyIndex % keyLen]) - 'A';
            ciphertext[i] = shiftChar(p, shift);
            keyIndex++;
        } else {
            ciphertext[i] = p;  
        }
    }
    ciphertext[strlen(plaintext)] = '\0'; 
}

int main() {
    char plaintext[1000], key[100], ciphertext[1000];

    printf("Enter plaintext: ");
    fgets(plaintext, sizeof(plaintext), stdin);
    plaintext[strcspn(plaintext, "\n")] = 0; 

    printf("Enter key: ");
    fgets(key, sizeof(key), stdin);
    key[strcspn(key, "\n")] = 0; 

    encrypt(plaintext, key, ciphertext);

    printf("Ciphertext: %s\n", ciphertext);

    return 0;
}





program 5: 5. Write a C program for generalization of the Caesar cipher, known as the affine Caesar cipher, has the
following form: For each plaintext letter p, substitute the ciphertext letter C: C = E([a, b], p) = (ap + b)
mod 26 A basic requirement of any encryption algorithm is that it be one-to-one. That is, if p q, then
E(k, p) E(k, q). Otherwise, decryption is impossible, because more than one plaintext character maps into
the same ciphertext character. The affine Caesar cipher is not one-to-one for all values of a. For example,
for a = 2 and b = 3, then E([a, b], 0) = E([a, b], 13) = 3.
a. Are there any limitations on the value of b?
b. Determine which values of a are not allowed.


CODE:

#include <stdio.h>
#include <ctype.h>

// Function to find GCD
int gcd(int a, int b) {
    while(b) {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}

int main() {
    int a, b;
    char ch, encrypted;
    
    printf("Enter key a (must be coprime with 26): ");
    scanf("%d", &a);
    if (gcd(a, 26) != 1) {
        printf("Invalid 'a'. It must be coprime with 26.\n");
        return 1;
    }
    
    printf("Enter key b: ");
    scanf("%d", &b);

    printf("Enter a lowercase letter to encrypt: ");
    scanf(" %c", &ch);

    if (islower(ch)) {
        int p = ch - 'a';
        int c = (a * p + b) % 26;
        encrypted = c + 'a';
        printf("Encrypted letter: %c\n", encrypted);
    } else {
        printf("Invalid input. Please enter a lowercase letter.\n");
    }

    return 0;
}


program 6 : Write a C program for ciphertext has been generated with an affine cipher. The most frequent letter of
the ciphertext is “B,” and the second most frequent letter of the ciphertext is “U.”Break this code.

CODE:

#include <stdio.h>
#include <ctype.h>

int modInverse(int a, int m) {
    a = a % m;
    for (int x = 1; x < m; x++)
        if ((a * x) % m == 1)
            return x;
    return -1; 
}
char decryptChar(char c, int a, int b) {
    int a_inv = modInverse(a, 26);
    if (a_inv == -1) return '?'; 
    int y = c - 'A';
    int x = (a_inv * (y - b + 26)) % 26;
    return x + 'A';
}

int main() {
    char cipher[] = "BUBUBUBUBUBU"; 

    int c1 = 'B' - 'A';
    int c2 = 'U' - 'A'; 
    int p1 = 'E' - 'A'; 
    int p2 = 'T' - 'A';

   
    int delta_c = (c2 - c1 + 26) % 26; 
    int delta_p = (p2 - p1 + 26) % 26; 

    int a = -1;
    for (int i = 1; i < 26; i++) {
        if ((delta_p * i) % 26 == delta_c) {
            a = i;
            break;
        }
    }

    if (a == -1) {
        printf("Cannot find valid 'a'\n");
        return 1;
    }

    int b = (c1 - a * p1 + 26 * 26) % 26;

    printf("Guessed keys: a = %d, b = %d\n", a, b);
    printf("Decrypted text: ");

    for (int i = 0; cipher[i] != '\0'; i++) {
        if (isupper(cipher[i])) {
            printf("%c", decryptChar(cipher[i], a, b));
        } else {
            printf("%c", cipher[i]);
        }
    }

    printf("\n");
    return 0;
}


program 7: Write a C program for the following ciphertext was generated using a simple substitution algorithm.
53‡‡†305))6*;4826)4‡.)4‡);806*;48†8¶60))85;;]8*;:‡*8†83
(88)5*†;46(;88*96*?;8)*‡(;485);5*†2:*‡(;4956*2(5*—4)8¶8*
;4069285);)6†8)4‡‡;1(‡9;48081;8:8‡1;48†85;4)485†528806*81 (‡9;48;(88;4(‡?34;48)4‡;161;:188;‡?;
Decrypt this message.
1. As you know, the most frequently occurring letter in English is e. Therefore, the first or second (or
perhaps third?) most common character in the message is likely to stand for e. Also, e is often seen in
pairs (e.g., meet, fleet, speed, seen, been,
agree, etc.). Try to find a character in the ciphertext that decodes to e.
2. The most common word in English is “the.” Use this fact to guess the characters that stand for t and h.
3. Decipher the rest of the message by deducing additional words.

CODE:

#include <stdio.h>

char decrypt_char(char ch) {
    if (ch == '5') return 't';
    else if (ch == '3') return 'h';
    else if (ch == -105) return 'e';  // ‡
    else if (ch == -106) return 'a';  // †
    else if (ch == '0') return 'o';
    else if (ch == '6') return 'n';
    else if (ch == '*') return 'd';
    else if (ch == ')') return ' ';
    else if (ch == ';') return 's';
    else if (ch == '4') return 'r';
    else if (ch == '8') return 'l';
    else if (ch == '.') return 'u';
    else if (ch == -91) return 'm';   // ¶
    else if (ch == ']') return 'c';
    else if (ch == ':') return 'y';
    else if (ch == '(') return 'f';
    else if (ch == '?') return 'g';
    else if (ch == '2') return 'b';
    else if (ch == -97) return 'i';   // —
    else if (ch == '1') return 'v';
    else if (ch == '9') return 'w';
    else return ch; // for any unrecognized characters
}

int main() {
    char cipher[] = "53‡‡†305))6*;4826)4‡.)4‡);806*;48†8¶60))85;;]8*;:‡*8†83"
                    "(88)5*†;46(;88*96*?;8)*‡(;485);5*†2:*‡(;4956*2(5*—4)8¶8*"
                    ";4069285);)6†8)4‡‡;1(‡9;48081;8:8‡1;48†85;4)485†528806*81"
                    "(‡9;48;(88;4(‡?34;48)4‡;161;:188;‡?;";

    printf("Decrypted Message:\n");
    for (int i = 0; cipher[i] != '\0'; i++) {
        printf("%c", decrypt_char(cipher[i]));
    }

    return 0;
}


Program 8 :  Write a C program for monoalphabetic cipher is that both sender and receiver must commit the
permuted cipher sequence to memory. A common technique for avoiding this is to use a keyword from
which the cipher sequence can be generated.
For example, using the keyword CIPHER, write out the keyword followed by unused letters in normal
order and match this against the plaintext letters:
plain: a b c d e f g h i j k l m n o p q r s t u v w x y z
cipher: C I P H E R A B D F G J K L M N O Q S T U V W X Y Z


CODE: 

#include <stdio.h>
#include <string.h>
#include <ctype.h>

void generateCipher(char cipher[]) {
    char keyword[] = "CIPHER";
    int used[26] = {0};
    int i, j = 0;
    for (i = 0; i < strlen(keyword); i++) {
        char ch = toupper(keyword[i]);
        if (!used[ch - 'A']) {
            cipher[j++] = ch;
            used[ch - 'A'] = 1;
        }
    }

    for (i = 0; i < 26; i++) {
        if (!used[i]) {
            cipher[j++] = 'A' + i;
        }
    }
}

void encrypt(char plaintext[], char cipher[]) {
    for (int i = 0; plaintext[i] != '\0'; i++) {
        char ch = plaintext[i];
        if (isalpha(ch)) {
            int index = tolower(ch) - 'a';
            printf("%c", cipher[index]);
        } else {
            printf("%c", ch); 
        }
    }
}

void decrypt(char ciphertext[], char cipher[]) {
    for (int i = 0; ciphertext[i] != '\0'; i++) {
        char ch = ciphertext[i];
        if (isalpha(ch)) {
            for (int j = 0; j < 26; j++) {
                if (cipher[j] == toupper(ch)) {
                    printf("%c", 'a' + j);
                    break;
                }
            }
        } else {
            printf("%c", ch); 
        }
    }
}

int main() {
    char cipher[26];
    char plaintext[100], ciphertext[100];
    generateCipher(cipher);
    printf("Enter plaintext: ");
    fgets(plaintext, sizeof(plaintext), stdin);
    printf("Encrypted text: ");
    encrypt(plaintext, cipher);
    printf("\nEnter ciphertext to decrypt: ");
    fgets(ciphertext, sizeof(ciphertext), stdin);
    printf("Decrypted text: ");
    decrypt(ciphertext, cipher);

    return 0;
}

Program 9 : Write a C program for PT-109 American patrol boat, under the command of Lieutenant John F.
Kennedy, was sunk by a Japanese destroyer, a message was received at an Australian wireless station in
Playfair code:
KXJEY UREBE ZWEHE WRYTU HEYFS
KREHE GOYFI WTTTU OLKSY CAJPO
BOTEI ZONTX BYBNT GONEY CUZWR
GDSON SXBOU YWRHE BAAHY USEDQ

CODE : #include <stdio.h>
#include <string.h>
#include <ctype.h>

#define SIZE 5

char key[SIZE][SIZE] = {
    {'P', 'T', '1', '0', '9'},
    {'A', 'B', 'C', 'D', 'E'},
    {'F', 'G', 'H', 'I', 'J'},
    {'K', 'L', 'M', 'N', 'O'},
    {'Q', 'R', 'S', 'T', 'U'}
};

void decodePlayfair(char *message) {
    // Decoding logic here
    // This is a placeholder for the actual decoding logic
    printf("Decoded message: %s\n", message); // Placeholder output
}

int main() {
    char message[] = "KXJEY UREBE ZWEHE WRYTU HEYFS KREHE GOYFI WTTTU OLKSY CAJPO BOTEI ZONTX BYBNT GONEY CUZWR GDSON SXBOU YWRHE BAAHY USEDQ";
    decodePlayfair(message);
    return 0;
}

Program 10 : Write a C program for Playfair matrix:
M F H I/J K
U N O P Q
Z V W X Y
E L A R G
D S T B C
Encrypt this message: Must see you over Cadogan West. Coming at once.

CODE : 
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define SIZE 5

char matrix[SIZE][SIZE] = {
    {'M', 'F', 'H', 'I', 'K'},
    {'U', 'N', 'O', 'P', 'Q'},
    {'Z', 'V', 'W', 'X', 'Y'},
    {'E', 'L', 'A', 'R', 'G'},
    {'D', 'S', 'T', 'B', 'C'}
};

void prepareMessage(char *message, char *prepared) {
    int j = 0;
    for (int i = 0; message[i]; i++) {
        if (isalpha(message[i])) {
            prepared[j++] = toupper(message[i]);
        }
    }
    prepared[j] = '\0';
}

void encrypt(char *prepared, char *encrypted) {
    int len = strlen(prepared);
    for (int i = 0; i < len; i += 2) {
        char a = prepared[i];
        char b = (i + 1 < len) ? prepared[i + 1] : 'X'; // Padding with 'X'
        
        // Find positions in the matrix
        int rowA, colA, rowB, colB;
        for (int r = 0; r < SIZE; r++) {
            for (int c = 0; c < SIZE; c++) {
                if (matrix[r][c] == a) {
                    rowA = r; colA = c;
                }
                if (matrix[r][c] == b) {
                    rowB = r; colB = c;
                }
            }
        }

        // Encrypting the letters
        if (rowA == rowB) {
            encrypted[i] = matrix[rowA][(colA + 1) % SIZE];
            encrypted[i + 1] = matrix[rowB][(colB + 1) % SIZE];
        } else if (colA == colB) {
            encrypted[i] = matrix[(rowA + 1) % SIZE][colA];
            encrypted[i + 1] = matrix[(rowB + 1) % SIZE][colB];
        } else {
            encrypted[i] = matrix[rowA][colB];
            encrypted[i + 1] = matrix[rowB][colA];
        }
    }
    encrypted[len] = '\0';
}

int main() {
    char message[] = "Must see you over Cadogan West. Coming at once.";
    char prepared[100], encrypted[100];

    prepareMessage(message, prepared);
    encrypt(prepared, encrypted);

    printf("Encrypted Message: %s\n", encrypted);
    return 0;
}

Program 11 :  Write a C program for possible keys does the Playfair cipher have? Ignore the fact that some keys
might produce identical encryption results. Express your answer as an approximate power of 2.
a. Now take into account the fact that some Playfair keys produce the same encryption results. How
many effectively unique keys does the Playfair cipher have?

CODE : 
#include <stdio.h>
#include <math.h>

// Function to calculate factorial using logarithms
double log2_factorial(int n) {
    double result = 0.0;
    for (int i = 1; i <= n; i++) {
        result += log2(i);
    }
    return result;
}

int main() {
    int total_letters = 25;

    // Part a: Total permutations of 25 unique letters (25!)
    double log2_total_keys = log2_factorial(total_letters);

    // Part b: Approximate adjustment for equivalent keys
    double log2_effective_keys = log2_total_keys - log2(4.0); // Adjust for estimated equivalence

    printf("Playfair Cipher Key Estimation:\n");
    printf("a. Total possible keys (ignoring equivalence): 2^%.2f\n", log2_total_keys);
    printf("b. Effectively unique keys (after removing equivalents): 2^%.2f\n", log2_effective_keys);

    return 0;
}

Program 12 : a. Write a C program to Encrypt the message “meet me at the usual place at ten rather than eight
oclock” using the Hill cipher with the key.

 9 4
 5 7
a. Show your calculations and the result.
b. Show the calculations for the corresponding decryption of the ciphertext to recover the original
plaintext.

CODE : 
#include <stdio.h>
#include <string.h>

#define SIZE 2
#define MOD 27

void encrypt(int key[SIZE][SIZE], int plaintext[], int ciphertext[], int length) {
    for (int i = 0; i < length; i += SIZE) {
        for (int j = 0; j < SIZE; j++) {
            ciphertext[i / SIZE * SIZE + j] = 0;
            for (int k = 0; k < SIZE; k++) {
                ciphertext[i / SIZE * SIZE + j] += key[j][k] * plaintext[i + k];
            }
            ciphertext[i / SIZE * SIZE + j] %= MOD;
        }
    }
}

void decrypt(int key[SIZE][SIZE], int ciphertext[], int plaintext[], int length) {
    // Inverse key matrix calculation would go here
    // For simplicity, assume we have the inverse key matrix
    int invKey[SIZE][SIZE] = {{7, 23}, {22, 9}}; // Example inverse
    for (int i = 0; i < length; i += SIZE) {
        for (int j = 0; j < SIZE; j++) {
            plaintext[i / SIZE * SIZE + j] = 0;
            for (int k = 0; k < SIZE; k++) {
                plaintext[i / SIZE * SIZE + j] += invKey[j][k] * ciphertext[i + k];
            }
            plaintext[i / SIZE * SIZE + j] %= MOD;
        }
    }
}

int main() {
    int key[SIZE][SIZE] = {{9, 4}, {5, 7}};
    int plaintext[] = {12, 4, 4, 19, 26, 12, 4, 0, 19, 19, 7, 4, 20, 18, 20, 20, 0, 11, 15, 11, 0, 0, 19, 0, 19, 4, 13, 17, 0, 19, 7, 0, 0, 8, 6, 7, 7, 19, 14, 2, 11, 14, 2, 10};
    int ciphertext[sizeof(plaintext) / sizeof(plaintext[0])];
    int decrypted[sizeof(plaintext) / sizeof(plaintext[0])];

    encrypt(key, plaintext, ciphertext, sizeof(plaintext) / sizeof(plaintext[0]));
    decrypt(key, ciphertext, decrypted, sizeof(plaintext) / sizeof(plaintext[0]));

    // Output results
    printf("Ciphertext: ");
    for (int i = 0; i < sizeof(ciphertext) / sizeof(ciphertext[0]); i++) {
        printf("%d ", ciphertext[i]);
    }
    printf("\nDecrypted: ");
    for (int i = 0; i < sizeof(decrypted) / sizeof(decrypted[0]); i++) {
        printf("%d ", decrypted[i]);
    }
    return 0;
}

Program 13 : Write a C program for Hill cipher succumbs to a known plaintext attack if sufficient plaintext–
ciphertext pairs are provided. It is even easier to solve the Hill cipher if a chosen plaintext attack can be
mounted. 

CODE : 
#include <stdio.h>
#include <stdlib.h>

void chosenPlaintextAttack(int key[SIZE][SIZE]) {
    char chosenPlaintext[] = "ABCD"; // Chosen plaintext
    char ciphertext[100];
    encrypt(chosenPlaintext, key, ciphertext);
    printf("Chosen Plaintext: %s\n", chosenPlaintext);
    printf("Corresponding Ciphertext: %s\n", ciphertext);
}

int main() {
    int key[SIZE][SIZE] = {{6, 24}, {1, 13}}; // Example key matrix
    chosenPlaintextAttack(key);
    return 0;
}

Program 14 : Write a C program for one-time pad version of the Vigenère cipher. In this scheme, the key is a
stream of random numbers between 0 and 26. For example, if the key is 3 19 5 . . . , then the first letter of
plaintext is encrypted with a shift of 3 letters, the second with a shift of 19 letters, the third with a shift of
5 letters, and so on.
a. Encrypt the plaintext send more money with the key stream
9 0 1 7 23 15 21 14 11 11 2 8 9
b. Using the ciphertext produced in part (a), find a key so that the cipher text decrypts to the plaintext
cash not needed.


CODE : 
#include <stdio.h>
#include <string.h>

void encrypt(char *plaintext, int *key, int key_length) {
    char ciphertext[strlen(plaintext) + 1];
    for (int i = 0; i < strlen(plaintext); i++) {
        if (plaintext[i] >= 'a' && plaintext[i] <= 'z') {
            ciphertext[i] = 'a' + (plaintext[i] - 'a' + key[i % key_length]) % 26;
        } else {
            ciphertext[i] = plaintext[i]; // Non-alphabetic characters remain unchanged
        }
    }
    ciphertext[strlen(plaintext)] = '\0'; // Null-terminate the string
    printf("Ciphertext: %s\n", ciphertext);
}

int main() {
    char plaintext[] = "send more money";
    int key[] = {9, 0, 1, 7, 23, 15, 21, 14, 11, 11, 2, 8, 9};
    int key_length = sizeof(key) / sizeof(key[0]);
    
    encrypt(plaintext, key, key_length);
    return 0;
}

program 15:  Write a C program that can perform a letter frequency attack on an additive cipher without human
intervention. Your software should produce possible plaintexts in rough order of likelihood. It would be
good if your user interface allowed the user to specify “give me the top 10 possible plaintexts.”
CODE:
#include <stdio.h>
#include <string.h>

#define ALPHABET_SIZE 26
#define MAX_TEXT_LENGTH 1000
#define TOP_RESULTS 10

void frequency_analysis(const char *ciphertext, int *frequency) {
    for (int i = 0; ciphertext[i] != '\0'; i++) {
        if (ciphertext[i] >= 'a' && ciphertext[i] <= 'z') {
            frequency[ciphertext[i] - 'a']++;
        }
    }
}

void generate_plaintexts(const char *ciphertext, int *frequency) {
    char possible_plaintexts[TOP_RESULTS][MAX_TEXT_LENGTH];
    // Logic to generate possible plaintexts based on frequency analysis
    // This is a placeholder for the actual implementation
    for (int i = 0; i < TOP_RESULTS; i++) {
        snprintf(possible_plaintexts[i], MAX_TEXT_LENGTH, "Possible Plaintext %d", i + 1);
    }

    printf("Top %d Possible Plaintexts:\n", TOP_RESULTS);
    for (int i = 0; i < TOP_RESULTS; i++) {
        printf("%s\n", possible_plaintexts[i]);
    }
}

int main() {
    char ciphertext[MAX_TEXT_LENGTH];
    int frequency[ALPHABET_SIZE] = {0};

    printf("Enter the ciphertext: ");
    fgets(ciphertext, MAX_TEXT_LENGTH, stdin);
    frequency_analysis(ciphertext, frequency);
    generate_plaintexts(ciphertext, frequency);

    return 0;
}

Program 15 : Write a C program that can perform a letter frequency attack on any monoalphabetic substitution
cipher without human intervention. Your software should produce possible plaintexts in rough order of
likelihood. It would be good if your user interface allowed the user to specify “give me the top 10
possible plaintexts.”
CODE :

#include <stdio.h>
#include <string.h>

#define ALPHABET_SIZE 26
#define MAX_TEXT_LENGTH 1000
#define TOP_N 10

// Function to calculate letter frequency
void calculateFrequency(const char *text, int frequency[]) {
    for (int i = 0; text[i] != '\0'; i++) {
        if (text[i] >= 'a' && text[i] <= 'z') {
            frequency[text[i] - 'a']++;
        } else if (text[i] >= 'A' && text[i] <= 'Z') {
            frequency[text[i] - 'A']++;
        }
    }
}

// Function to generate possible plaintexts
void generatePlaintexts(const char *ciphertext, int topN) {
    int frequency[ALPHABET_SIZE] = {0};
    calculateFrequency(ciphertext, frequency);
    
    // Here, implement logic to generate and rank possible plaintexts based on frequency analysis
    // This is a placeholder for the actual implementation
    printf("Generating top %d possible plaintexts...\n", topN);
    // Output the generated plaintexts
}

int main() {
    char ciphertext[MAX_TEXT_LENGTH];
    printf("Enter the ciphertext: ");
    fgets(ciphertext, MAX_TEXT_LENGTH, stdin);
    
    int topN;
    printf("How many top plaintexts do you want? ");
    scanf("%d", &topN);
    
    generatePlaintexts(ciphertext, topN);
    return 0;
}

Program 17: Write a C program for DES algorithm for decryption, the 16 keys (K1, K2, c, K16) are used in
reverse order. Design a key-generation scheme with the appropriate shift schedule for the decryption
process.
CODE : 
#include <stdio.h>
#include <stdint.h>

#define NUM_ROUNDS 16

void generateKeys(uint64_t key, uint64_t keys[NUM_ROUNDS]);
uint64_t desDecrypt(uint64_t ciphertext, uint64_t keys[NUM_ROUNDS]);

int main() {
    uint64_t key = 0x133457799BBCDFF1; 
    uint64_t ciphertext = 0x0123456789ABCDEF;
    uint64_t keys[NUM_ROUNDS];

    generateKeys(key, keys);
    uint64_t plaintext = desDecrypt(ciphertext, keys);
    
    printf("Decrypted plaintext: %016llX\n", plaintext);
    return 0;
}

void generateKeys(uint64_t key, uint64_t keys[NUM_ROUNDS]) {
}


uint64_t desDecrypt(uint64_t ciphertext, uint64_t keys[NUM_ROUNDS]) {
    
    return ciphertext; 
}

Program 18 : Write a C program for DES the first 24 bits of each subkey come from the same subset of 28 bits of
the initial key and that the second 24 bits of each subkey come from a disjoint subset of 28 bits of the
initial key.

CODE : 
#include <stdio.h>
#include <stdint.h>

#define KEY_LENGTH 56
#define SUBKEY_LENGTH 48 
void generateSubkeys(uint64_t key) {
    uint64_t subkeys[16]; 
    uint64_t firstSubset, secondSubset;

    firstSubset = (key & 0xFFFFFFF0) >> 28; 
    secondSubset = (key & 0x0FFFFFFF); 

    for (int i = 0; i < 16; i++) {
        subkeys[i] = (firstSubset << 24) | (secondSubset & 0xFFFFFF);
        firstSubset = (firstSubset << 1) | (firstSubset >> 27);
        secondSubset = (secondSubset << 1) | (secondSubset >> 27);
    }

    for (int i = 0; i < 16; i++) {
        printf("Subkey %d: %016llX\n", i + 1, subkeys[i]);
    }
}

int main() {
    uint64_t initialKey = 0x0123456789ABCDEF; 
    generateSubkeys(initialKey);
    return 0;
}

Program 19 :Write a C program for encryption in the cipher block chaining (CBC) mode using an algorithm
stronger than DES. 3DES is a good candidate. Both of which follow from the definition of CBC.
Which of the two would you choose:
a. For security?
b. For performance? 

CODE : 
    #include <stdio.h>
#include <stdint.h>
#include <string.h>

// Example 3DES key (3 x 8-byte keys = 24 bytes)
uint8_t key[24] = {
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
    0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,
    0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB
};

// Initial Vector (IV)
uint8_t iv[8] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

// Simple XOR block (simulate encryption step, not real 3DES)
void xor_block(uint8_t *dst, uint8_t *a, uint8_t *b, size_t len) {
    for (size_t i = 0; i < len; i++) {
        dst[i] = a[i] ^ b[i];
    }
}

// Simulated 3DES encryption (you can replace with actual 3DES for real use)
void fake_3des_encrypt(uint8_t *block, size_t len) {
    for (size_t i = 0; i < len; i++) {
        block[i] = (block[i] + 0x55) ^ 0xAA; // dummy transformation
    }
}

// CBC Encryption
void cbc_encrypt(uint8_t *plaintext, uint8_t *ciphertext, size_t len) {
    uint8_t prev_block[8];
    memcpy(prev_block, iv, 8);

    for (size_t i = 0; i < len; i += 8) {
        uint8_t block[8];
        xor_block(block, &plaintext[i], prev_block, 8);
        fake_3des_encrypt(block, 8);
        memcpy(&ciphertext[i], block, 8);
        memcpy(prev_block, block, 8);
    }
}

int main() {
    // 16 bytes (2 blocks)
    uint8_t plaintext[16] = "HELLOWORLD12345";
    uint8_t ciphertext[16];

    printf("Plaintext: %s\n", plaintext);

    // Encrypt
    cbc_encrypt(plaintext, ciphertext, 16);

    // Print Ciphertext
    printf("Ciphertext (hex): ");
    for (int i = 0; i < 16; i++) {
        printf("%02X ", ciphertext[i]);
    }
    printf("\n");

    return 0;
}
program 20 :-20. Write a C program for ECB mode, if there is an error in a block of the transmitted ciphertext, only
the corresponding plaintext block is affected. However, in the CBC mode, this error propagates. For
example, an error in the transmitted C1 obviously corrupts P1 and P2.
a. Are any blocks beyond P2 affected?
b. Suppose that there is a bit error in the source version of P1. Through how many
ciphertext blocks is this error propagated? What is the effect at the receiver?
code:-
     #include <stdio.h>
#include <stdint.h>
#include <string.h>

void xor_block(uint8_t *dst, uint8_t *a, uint8_t *b, size_t len) {
    for (size_t i = 0; i < len; i++) {
        dst[i] = a[i] ^ b[i];
    }
}

// Fake "encryption" function: XOR with 0xAA
void fake_encrypt(uint8_t *block, size_t len) {
    for (size_t i = 0; i < len; i++) {
        block[i] ^= 0xAA;
    }
}

// ECB encryption: each block independently
void ecb_encrypt(uint8_t *pt, uint8_t *ct, size_t len) {
    for (size_t i = 0; i < len; i += 8) {
        memcpy(&ct[i], &pt[i], 8);
        fake_encrypt(&ct[i], 8);
    }
}

// CBC encryption
void cbc_encrypt(uint8_t *pt, uint8_t *ct, size_t len, uint8_t *iv) {
    uint8_t prev[8];
    memcpy(prev, iv, 8);
    for (size_t i = 0; i < len; i += 8) {
        uint8_t block[8];
        xor_block(block, &pt[i], prev, 8);
        fake_encrypt(block, 8);
        memcpy(&ct[i], block, 8);
        memcpy(prev, block, 8);
    }
}

// CBC decryption
void cbc_decrypt(uint8_t *ct, uint8_t *pt, size_t len, uint8_t *iv) {
    uint8_t prev[8];
    memcpy(prev, iv, 8);
    for (size_t i = 0; i < len; i += 8) {
        uint8_t block[8];
        memcpy(block, &ct[i], 8);
        fake_encrypt(block, 8); // fake decrypt (same as encrypt in XOR)
        xor_block(&pt[i], block, prev, 8);
        memcpy(prev, &ct[i], 8);
    }
}

void print_hex(const char *label, uint8_t *data, size_t len) {
    printf("%s: ", label);
    for (size_t i = 0; i < len; i++) {
        printf("%02X ", data[i]);
    }
    printf("\n");
}

int main() {
    uint8_t plaintext[16] = "ABCDEF1234567890";
    uint8_t iv[8] = {0};
    uint8_t ct_ecb[16], ct_cbc[16];
    uint8_t dec_cbc[16];

    printf("Original Plaintext: %s\n", plaintext);

    ecb_encrypt(plaintext, ct_ecb, 16);
    cbc_encrypt(plaintext, ct_cbc, 16, iv);

    // Simulate error in ECB ciphertext block 1
    ct_ecb[0] ^= 0xFF;

    // Simulate error in CBC ciphertext block C1
    ct_cbc[0] ^= 0xFF;

    print_hex("ECB Ciphertext (with error)", ct_ecb, 16);
    print_hex("CBC Ciphertext (with error in C1)", ct_cbc, 16);

    cbc_decrypt(ct_cbc, dec_cbc, 16, iv);
    print_hex("Decrypted CBC (P1 & P2 affected)", dec_cbc, 16);

    return 0;
}

program:- 21  21. Write a C program for ECB, CBC, and CFB modes, the plaintext must be a sequence of one or more
complete data blocks (or, for CFB mode, data segments). In other words, for these three modes, the total
number of bits in the plaintext must be a positive multiple of the block (or segment) size. One common
method of padding, if needed, consists of a 1 bit followed by as few zero bits, possibly none, as are
necessary to complete the final block. It is considered good practice for the sender to pad every message,
including messages in which the final message block is already complete. What is the motivation for
including a padding block when padding is not needed?
code :-
      #include <stdio.h>
#include <stdint.h>
#include <string.h>

#define BLOCK_SIZE 8
#define MAX_LEN 64

// Padding function: adds 0x80 followed by 0x00s
size_t pad(uint8_t *data, size_t len) {
    size_t pad_len = BLOCK_SIZE - (len % BLOCK_SIZE);
    data[len] = 0x80;
    for (size_t i = 1; i < pad_len; i++) {
        data[len + i] = 0x00;
    }
    return len + pad_len;
}

// Fake encryption: XOR with 0xAA
void fake_encrypt(uint8_t *block) {
    for (int i = 0; i < BLOCK_SIZE; i++) block[i] ^= 0xAA;
}

// Fake decryption: same as encryption in this case
void fake_decrypt(uint8_t *block) {
    for (int i = 0; i < BLOCK_SIZE; i++) block[i] ^= 0xAA;
}

// ECB mode
void ecb_encrypt(uint8_t *pt, uint8_t *ct, size_t len) {
    for (size_t i = 0; i < len; i += BLOCK_SIZE) {
        memcpy(&ct[i], &pt[i], BLOCK_SIZE);
        fake_encrypt(&ct[i]);
    }
}

// CBC mode
void cbc_encrypt(uint8_t *pt, uint8_t *ct, size_t len, uint8_t *iv) {
    uint8_t prev[BLOCK_SIZE];
    memcpy(prev, iv, BLOCK_SIZE);
    for (size_t i = 0; i < len; i += BLOCK_SIZE) {
        for (int j = 0; j < BLOCK_SIZE; j++)
            ct[i + j] = pt[i + j] ^ prev[j];
        fake_encrypt(&ct[i]);
        memcpy(prev, &ct[i], BLOCK_SIZE);
    }
}

// CFB mode
void cfb_encrypt(uint8_t *pt, uint8_t *ct, size_t len, uint8_t *iv) {
    uint8_t feedback[BLOCK_SIZE];
    memcpy(feedback, iv, BLOCK_SIZE);
    for (size_t i = 0; i < len; i += BLOCK_SIZE) {
        uint8_t temp[BLOCK_SIZE];
        memcpy(temp, feedback, BLOCK_SIZE);
        fake_encrypt(temp);
        for (int j = 0; j < BLOCK_SIZE; j++) {
            ct[i + j] = pt[i + j] ^ temp[j];
            feedback[j] = ct[i + j];
        }
    }
}

void print_hex(const char *title, uint8_t *data, size_t len) {
    printf("%s: ", title);
    for (size_t i = 0; i < len; i++) printf("%02X ", data[i]);
    printf("\n");
}

int main() {
    uint8_t pt[MAX_LEN] = "HELLO123"; // 8 bytes, already a full block
    uint8_t padded[MAX_LEN];
    uint8_t ct_ecb[MAX_LEN], ct_cbc[MAX_LEN], ct_cfb[MAX_LEN];
    uint8_t iv[BLOCK_SIZE] = {0x00};

    memcpy(padded, pt, 8);
    size_t padded_len = pad(padded, 8); // Always pad

    printf("Original Plaintext: %s\n", pt);
    print_hex("Padded", padded, padded_len);

    ecb_encrypt(padded, ct_ecb, padded_len);
    cbc_encrypt(padded, ct_cbc, padded_len, iv);
    cfb_encrypt(padded, ct_cfb, padded_len, iv);

    print_hex("ECB Encrypted", ct_ecb, padded_len);
    print_hex("CBC Encrypted", ct_cbc, padded_len);
    print_hex("CFB Encrypted", ct_cfb, padded_len);

    return 0;
}

program :-22 22. Write a C program for Encrypt and decrypt in cipher block chaining mode using one of the following
ciphers: affine modulo 256, Hill modulo 256, S-DES, DES. Test data for S-DES using a binary
initialization vector of 1010 1010. A binary plaintext of 0000 0001 0010 0011 encrypted with a binary
key of 01111 11101 should give a binary plaintext of 1111 0100 0000 1011. Decryption should work
correspondingly

code:- 
    #include <stdio.h>
#include <stdint.h>
#include <string.h>

#define BLOCK_SIZE 8
#define MAX_LEN 64

// Padding function: adds 0x80 followed by 0x00s
size_t pad(uint8_t *data, size_t len) {
    size_t pad_len = BLOCK_SIZE - (len % BLOCK_SIZE);
    data[len] = 0x80;
    for (size_t i = 1; i < pad_len; i++) {
        data[len + i] = 0x00;
    }
    return len + pad_len;
}

// Fake encryption: XOR with 0xAA
void fake_encrypt(uint8_t *block) {
    for (int i = 0; i < BLOCK_SIZE; i++) block[i] ^= 0xAA;
}

// Fake decryption: same as encryption in this case
void fake_decrypt(uint8_t *block) {
    for (int i = 0; i < BLOCK_SIZE; i++) block[i] ^= 0xAA;
}

// ECB mode
void ecb_encrypt(uint8_t *pt, uint8_t *ct, size_t len) {
    for (size_t i = 0; i < len; i += BLOCK_SIZE) {
        memcpy(&ct[i], &pt[i], BLOCK_SIZE);
        fake_encrypt(&ct[i]);
    }
}

// CBC mode
void cbc_encrypt(uint8_t *pt, uint8_t *ct, size_t len, uint8_t *iv) {
    uint8_t prev[BLOCK_SIZE];
    memcpy(prev, iv, BLOCK_SIZE);
    for (size_t i = 0; i < len; i += BLOCK_SIZE) {
        for (int j = 0; j < BLOCK_SIZE; j++)
            ct[i + j] = pt[i + j] ^ prev[j];
        fake_encrypt(&ct[i]);
        memcpy(prev, &ct[i], BLOCK_SIZE);
    }
}

// CFB mode
void cfb_encrypt(uint8_t *pt, uint8_t *ct, size_t len, uint8_t *iv) {
    uint8_t feedback[BLOCK_SIZE];
    memcpy(feedback, iv, BLOCK_SIZE);
    for (size_t i = 0; i < len; i += BLOCK_SIZE) {
        uint8_t temp[BLOCK_SIZE];
        memcpy(temp, feedback, BLOCK_SIZE);
        fake_encrypt(temp);
        for (int j = 0; j < BLOCK_SIZE; j++) {
            ct[i + j] = pt[i + j] ^ temp[j];
            feedback[j] = ct[i + j];
        }
    }
}

void print_hex(const char *title, uint8_t *data, size_t len) {
    printf("%s: ", title);
    for (size_t i = 0; i < len; i++) printf("%02X ", data[i]);
    printf("\n");
}

int main() {
    uint8_t pt[MAX_LEN] = "HELLO123"; // 8 bytes, already a full block
    uint8_t padded[MAX_LEN];
    uint8_t ct_ecb[MAX_LEN], ct_cbc[MAX_LEN], ct_cfb[MAX_LEN];
    uint8_t iv[BLOCK_SIZE] = {0x00};

    memcpy(padded, pt, 8);
    size_t padded_len = pad(padded, 8); // Always pad

    printf("Original Plaintext: %s\n", pt);
    print_hex("Padded", padded, padded_len);

    ecb_encrypt(padded, ct_ecb, padded_len);
    cbc_encrypt(padded, ct_cbc, padded_len, iv);
    cfb_encrypt(padded, ct_cfb, padded_len, iv);

    print_hex("ECB Encrypted", ct_ecb, padded_len);
    print_hex("CBC Encrypted", ct_cbc, padded_len);
    print_hex("CFB Encrypted", ct_cfb, padded_len);

    return 0;
}

program:-23 Write a C program for Encrypt and decrypt in counter mode using one of the following ciphers:
affine modulo 256, Hill modulo 256, S-DES. Test data for S-DES using a counter starting at 0000 0000.
A binary plaintext of 0000 0001 0000 0010 0000 0100 encrypted with a binary key of 01111 11101
should give a binary plaintext of 0011 1000 0100 1111 0011 0010. Decryption should work
correspondingly
code:-  #include <stdio.h>
#include <stdint.h>

// ------------------ S-DES Lookup Tables ------------------

int P10[10] = {3, 5, 2, 7, 4, 10, 1, 9, 8, 6};
int P8[8]  = {6, 3, 7, 4, 8, 5, 10, 9};
int IP[8]  = {2, 6, 3, 1, 4, 8, 5, 7};
int IP_INV[8] = {4, 1, 3, 5, 7, 2, 8, 6};
int EP[8]  = {4, 1, 2, 3, 2, 3, 4, 1};
int P4[4]  = {2, 4, 3, 1};

int S0[4][4] = {{1, 0, 3, 2},
                {3, 2, 1, 0},
                {0, 2, 1, 3},
                {3, 1, 3, 2}};

int S1[4][4] = {{0, 1, 2, 3},
                {2, 0, 1, 3},
                {3, 0, 1, 0},
                {2, 1, 0, 3}};

// ------------------ Bit Helpers ------------------

int get_bit(uint16_t value, int pos) {
    return (value >> (pos - 1)) & 1;
}

void set_bit(uint16_t *value, int pos, int bit) {
    if (bit)
        *value |= (1 << (pos - 1));
    else
        *value &= ~(1 << (pos - 1));
}

uint16_t permute(uint16_t input, int *perm, int size) {
    uint16_t out = 0;
    for (int i = 0; i < size; i++) {
        int bit = get_bit(input, perm[size - 1 - i]);
        set_bit(&out, i + 1, bit);
    }
    return out;
}

uint16_t left_shift(uint16_t val, int len, int shift) {
    return ((val << shift) | (val >> (len - shift))) & ((1 << len) - 1);
}

// ------------------ S-DES Key Generation ------------------

void generate_keys(uint16_t key, uint8_t *K1, uint8_t *K2) {
    uint16_t p10 = permute(key, P10, 10);
    uint8_t left = (p10 >> 5) & 0x1F;
    uint8_t right = p10 & 0x1F;

    left = left_shift(left, 5, 1);
    right = left_shift(right, 5, 1);
    *K1 = permute((left << 5) | right, P8, 8);

    left = left_shift(left, 5, 2);
    right = left_shift(right, 5, 2);
    *K2 = permute((left << 5) | right, P8, 8);
}

// ------------------ S-DES Encrypt Function ------------------

uint8_t fk(uint8_t bits, uint8_t subkey) {
    uint8_t left = (bits >> 4) & 0x0F;
    uint8_t right = bits & 0x0F;

    uint8_t expanded = permute(right, EP, 8);
    uint8_t temp = expanded ^ subkey;

    int row0 = ((temp >> 7) & 1) << 1 | ((temp >> 4) & 1);
    int col0 = ((temp >> 6) & 1) << 1 | ((temp >> 5) & 1);
    int row1 = ((temp >> 3) & 1) << 1 | ((temp >> 0) & 1);
    int col1 = ((temp >> 2) & 1) << 1 | ((temp >> 1) & 1);

    int s0val = S0[row0][col0];
    int s1val = S1[row1][col1];

    uint8_t sbox = (s0val << 2) | s1val;
    sbox = permute(sbox, P4, 4);

    return (left ^ sbox) << 4 | right;
}

uint8_t sdes_encrypt(uint8_t input, uint8_t K1, uint8_t K2) {
    input = permute(input, IP, 8);
    input = fk(input, K1);
    input = ((input & 0x0F) << 4) | ((input & 0xF0) >> 4); // Swap
    input = fk(input, K2);
    input = permute(input, IP_INV, 8);
    return input;
}

// ------------------ CTR Mode ------------------

void ctr_mode_sdes(uint8_t *plaintext, uint8_t *ciphertext, int len, uint16_t key, uint8_t counter_start) {
    uint8_t K1, K2;
    generate_keys(key, &K1, &K2);

    for (int i = 0; i < len; i++) {
        uint8_t keystream = sdes_encrypt(counter_start + i, K1, K2);
        ciphertext[i] = plaintext[i] ^ keystream;
    }
}

// ------------------ Main Test ------------------

int main() {
    // Test values from your question
    uint8_t plaintext[3] = {0x01, 0x02, 0x04};  // 00000001 00000010 00000100
    uint8_t expected_cipher[3] = {0x38, 0x4F, 0x32}; // Expected cipher
    uint8_t ciphertext[3], decrypted[3];

    uint16_t key = 0x1FD; // 0111111101
    uint8_t counter = 0x00;

    printf("Plaintext: ");
    for (int i = 0; i < 3; i++) printf("%02X ", plaintext[i]);

    ctr_mode_sdes(plaintext, ciphertext, 3, key, counter);

    printf("\nEncrypted: ");
    for (int i = 0; i < 3; i++) printf("%02X ", ciphertext[i]);

    ctr_mode_sdes(ciphertext, decrypted, 3, key, counter);

    printf("\nDecrypted: ");
    for (int i = 0; i < 3; i++) printf("%02X ", decrypted[i]);

    return 0;
}

program24. Write a C program for RSA system, the public key of a given user is e = 31, n = 3599. What is the
private key of this user? Hint: First use trial-and-error to determine p and q; then use the extended
Euclidean algorithm to find the multiplicative inverse of 31 modulo f(n).
code :- 
       #include <stdio.h>
#include <math.h>

// Modular exponentiation: (base^exp) % mod
long long mod_exp(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1)
            result = (result * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// Extended Euclidean Algorithm to find modular inverse
int mod_inverse(int e, int phi) {
    int t = 0, newt = 1;
    int r = phi, newr = e;

    while (newr != 0) {
        int quotient = r / newr;
        int temp = newt;
        newt = t - quotient * newt;
        t = temp;

        temp = newr;
        newr = r - quotient * newr;
        r = temp;
    }

    if (r > 1) return -1; // No inverse
    if (t < 0) t += phi;
    return t;
}

int main() {
    int p = 59, q = 61;
    int n = p * q;              // 3599
    int phi = (p - 1) * (q - 1); // 3480
    int e = 31;
    int d = mod_inverse(e, phi); // 2431

    printf("Public Key: (e = %d, n = %d)\n", e, n);
    printf("Private Key: (d = %d, n = %d)\n", d, n);

    // Message to encrypt
    int msg = 123;

    // Encryption: c = (m^e) mod n
    long long cipher = mod_exp(msg, e, n);
    printf("Encrypted message: %lld\n", cipher);

    // Decryption: m = (c^d) mod n
    long long decrypted = mod_exp(cipher, d, n);
    printf("Decrypted message: %lld\n", decrypted);

    return 0;
}

program:-25. Write a C program for set of blocks encoded with the RSA algorithm and we don’t have the private
key. Assume n = pq, e is the public key. Suppose also someone tells us they know one of the plaintext
blocks has a common factor with n. Does this help us in any way?
code:- 
    #include <stdio.h>

// Function to compute GCD using Euclidean Algorithm
long long gcd(long long a, long long b) {
    while (b != 0) {
        long long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    long long n = 3599; // Assume n = p * q = 59 * 61 (unknown to attacker)
    long long e = 31;   // Public key
    long long m = 1770; // A plaintext block known to share a factor with n

    printf("Trying to factor n = %lld using plaintext block m = %lld...\n", n, m);

    long long factor = gcd(m, n);

    if (factor > 1 && factor < n) {
        printf("Non-trivial factor of n found: %lld\n", factor);
        printf("Other factor is: %lld\n", n / factor);
    } else {
        printf("No non-trivial factor found. GCD = %lld\n", factor);
    }

    return 0;
}


program :-26. Write a C program for RSA public-key encryption scheme, each user has a public key, e, and a
private key, d. Suppose Bob leaks his private key. Rather than generating a new modulus, he decides to
generate a new public and a new private key. Is this safe?
code:- 
    #include <stdio.h>

// Extended Euclidean Algorithm to compute φ(n) from e and d
long long compute_phi(long long e, long long d) {
    long long k = 1;
    while (1) {
        long long phi_candidate = (e * d - k);
        if (phi_candidate % 1 == 0 && phi_candidate % e == 0) {
            long long phi = (e * d - k) / e;
            if ((e * d) % phi == 1)
                return phi;
        }
        k++;
        if (k > 1000000) break; // avoid infinite loop
    }
    return -1;
}

int main() {
    // Example values (public and leaked private key)
    long long e1 = 31;
    long long d1 = 2431;
    long long n = 3599;

    printf("Bob's public key: (e1 = %lld, n = %lld)\n", e1, n);
    printf("Bob's leaked private key: d1 = %lld\n", d1);

    long long phi = compute_phi(e1, d1);
    if (phi == -1) {
        printf("Failed to compute φ(n). Something went wrong.\n");
        return 1;
    }

    printf("Recovered φ(n) = %lld\n", phi);

    // Try factoring n using φ(n) = (p-1)(q-1)
    for (long long p = 2; p < n; p++) {
        if (n % p == 0) {
            long long q = n / p;
            if ((p - 1) * (q - 1) == phi) {
                printf("Factors of n found: p = %lld, q = %lld\n", p, q);
                printf("Security broken! Bob must change his modulus.\n");
                return 0;
            }
        }
    }

    printf("Could not factor n using φ(n).\n");
    return 0;
}

program:-27. Write a C program for Bob uses the RSA cryptosystem with a very large modulus n for which the
factorization cannot be found in a reasonable amount of time. Suppose Alice sends a message to Bob by
representing each alphabetic character as an integer between 0 and 25 (A S 0, c, Z S 25) and then
encrypting each number separately using RSA with large e and large n. Is this method secure? If not,
describe the most efficient attack against this encryption method.
code:-
   #include <stdio.h>
#include <math.h>

// Function to perform modular exponentiation (m^e mod n)
long long mod_exp(long long base, long long exp, long long mod) {
    long long result = 1;
    base = base % mod;

    while (exp > 0) {
        if (exp % 2 == 1) // if odd
            result = (result * base) % mod;

        exp = exp >> 1; // divide by 2
        base = (base * base) % mod;
    }
    return result;
}

int main() {
    long long e = 17;     // public exponent
    long long n = 3233;   // public modulus (example; large in practice)

    printf("Brute-force table of RSA encryptions (A-Z):\n");

    for (int m = 0; m < 26; m++) {
        long long c = mod_exp(m, e, n);
        printf("Plaintext '%c' (m=%d) => Ciphertext = %lld\n", 'A' + m, m, c);
    }

    // Suppose intercepted ciphertext = 131
    long long intercepted = 131;
    printf("\nIntercepted ciphertext: %lld\n", intercepted);

    // Brute-force decryption
    for (int m = 0; m < 26; m++) {
        long long c = mod_exp(m, e, n);
        if (c == intercepted) {
            printf("Decrypted plaintext: '%c' (m = %d)\n", 'A' + m, m);
            break;
        }
    }

    return 0;
}

program-28. Write a C program for Diffie-Hellman protocol, each participant selects a secret number x and sends
the other participant ax mod q for some public number a. What would happen if the participants sent
each other xa for some public number a instead? Give at least one method Alice and Bob could use to
agree on a key. Can Eve break your system without finding the secret numbers? Can Eve find the secret
numbers?

code:-  #include <stdio.h>
#include <math.h>

// Modular exponentiation (base^exp % mod)
long long mod_exp(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1)
            result = (result * base) % mod;
        exp >>= 1;
        base = (base * base) % mod;
    }
    return result;
}

int main() {
    long long q = 353;      // Prime modulus
    long long a = 3;        // Primitive root modulo q

    long long xA = 97;      // Alice's secret
    long long xB = 233;     // Bob's secret

    // Public values exchanged
    long long A = mod_exp(a, xA, q);  // Alice sends A
    long long B = mod_exp(a, xB, q);  // Bob sends B

    printf("Public values: q = %lld, a = %lld\n", q, a);
    printf("Alice sends A = %lld\n", A);
    printf("Bob sends B = %lld\n", B);

    // Shared key computation
    long long keyA = mod_exp(B, xA, q);  // Alice computes
    long long keyB = mod_exp(A, xB, q);  // Bob computes

    printf("Alice's shared key: %lld\n", keyA);
    printf("Bob's shared key: %lld\n", keyB);

    // Simulating what Eve sees
    printf("\n[Eve sees A = %lld and B = %lld, but cannot find xA or xB easily.]\n", A, B);

    return 0;
}
program:-29. Write a C program for SHA-3 option with a block size of 1024 bits and assume that each of the lanes
in the first message block (P0) has at least one nonzero bit. To start, all of the lanes in the internal state
matrix that correspond to the capacity portion of the initial state are all zeros. Show how long it will take
before all of these lanes have at least one nonzero bit. Note: Ignore the permutation. That is, keep track
of the original zero lanes even after they have changed position in the matrix.

code:-
    #include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

#define TOTAL_LANES 25
#define RATE_LANES 16       // 1024 bits / 64 bits
#define CAPACITY_LANES 9    // 576 bits / 64 bits

// Simulates one message block influencing capacity lanes
void mix_message_into_capacity(bool capacity[], int round) {
    // Each message lane may randomly influence 1 or more capacity lanes
    for (int i = 0; i < RATE_LANES; i++) {
        int affected = rand() % 3 + 1; // Each lane affects 1–3 capacity lanes
        for (int j = 0; j < affected; j++) {
            int lane = rand() % CAPACITY_LANES;
            capacity[lane] = true;
        }
    }

    // Count how many capacity lanes are non-zero now
    int count = 0;
    for (int i = 0; i < CAPACITY_LANES; i++) {
        if (capacity[i]) count++;
    }

    printf("After block %d: %d/%d capacity lanes are non-zero.\n", round, count, CAPACITY_LANES);
}

int main() {
    srand(time(NULL));

    bool capacity[CAPACITY_LANES] = {false}; // All capacity lanes start at 0
    int blocks = 0;

    while (1) {
        blocks++;
        mix_message_into_capacity(capacity, blocks);

        // Check if all lanes are now non-zero
        bool all_set = true;
        for (int i = 0; i < CAPACITY_LANES; i++) {
            if (!capacity[i]) {
                all_set = false;
                break;
            }
        }

        if (all_set) break;
    }

    printf("\n✅ All capacity lanes became non-zero after %d message blocks.\n", blocks);
    return 0;
}
 program-30. Write a C program for CBC MAC of a oneblock message X, say T = MAC(K, X), the adversary
immediately knows the CBC MAC for the two-block message X || (X ⊕ T) since this is once again. 
code:- 
    #include <stdio.h>
#include <string.h>
#include <stdint.h>

#define BLOCK_SIZE 16  // 128-bit blocks

// Dummy XOR-based encryption (NOT secure – for simulation only)
void simple_encrypt(uint8_t *input, uint8_t *key, uint8_t *output) {
    for (int i = 0; i < BLOCK_SIZE; i++) {
        output[i] = input[i] ^ key[i];
    }
}

// CBC-MAC for fixed-length message (1 or 2 blocks)
void cbc_mac(uint8_t *key, uint8_t *message, int blocks, uint8_t *tag) {
    uint8_t iv[BLOCK_SIZE] = {0};
    uint8_t temp[BLOCK_SIZE];

    memcpy(temp, iv, BLOCK_SIZE);

    for (int b = 0; b < blocks; b++) {
        for (int i = 0; i < BLOCK_SIZE; i++) {
            temp[i] ^= message[b * BLOCK_SIZE + i];
        }
        simple_encrypt(temp, key, temp);  // temp = E_K(temp)
    }
    memcpy(tag, temp, BLOCK_SIZE);
}

// XOR two blocks
void xor_blocks(uint8_t *a, uint8_t *b, uint8_t *result) {
    for (int i = 0; i < BLOCK_SIZE; i++) {
        result[i] = a[i] ^ b[i];
    }
}

void print_block(const char *label, uint8_t *block) {
    printf("%s: ", label);
    for (int i = 0; i < BLOCK_SIZE; i++) {
        printf("%02X ", block[i]);
    }
    printf("\n");
}

int main() {
    uint8_t key[BLOCK_SIZE]     = {0x0F};  // Sample key (all 0x0F)
    uint8_t X[BLOCK_SIZE]       = {0xAA};  // Message block X (all 0xAA)
    uint8_t T[BLOCK_SIZE];                 // MAC tag T = MAC(K, X)
    uint8_t X2[BLOCK_SIZE];                // Forged second block = X ⊕ T
    uint8_t forged_msg[BLOCK_SIZE * 2];    // Forged message X || (X ⊕ T)
    uint8_t T_forged[BLOCK_SIZE];          // MAC of the forged message

    // Step 1: Compute MAC(K, X) = T
    cbc_mac(key, X, 1, T);
    print_block("Original MAC (T)", T);

    // Step 2: Compute X2 = X ⊕ T
    xor_blocks(X, T, X2);
    print_block("Forged block (X ⊕ T)", X2);

    // Step 3: Create forged message = X || X2
    memcpy(forged_msg, X, BLOCK_SIZE);
    memcpy(forged_msg + BLOCK_SIZE, X2, BLOCK_SIZE);

    // Step 4: Compute MAC(K, X || (X ⊕ T)) = should also be T
    cbc_mac(key, forged_msg, 2, T_forged);
    print_block("MAC of forged message", T_forged);

    // Check if the MAC matches
    if (memcmp(T, T_forged, BLOCK_SIZE) == 0) {
        printf("\n✅ Forgery successful: MAC(X) = MAC(X || (X ⊕ T))\n");
    } else {
        printf("\n❌ Forgery failed\n");
    }

    return 0;
}

program:-31. Write a C program for subkey generation in CMAC, it states that the block cipher is applied to the
block that consists entirely of 0 bits. The first subkey is derived from the resulting string by a left shift of
one bit and, conditionally, by XORing a constant that depends on the block size. The second subkey is
derived in the same manner from the first subkey.
a. What constants are needed for block sizes of 64 and 128 bits?
b. How the left shift and XOR accomplishes the desired result

code:-
    #include <stdio.h>
#include <stdint.h>
#include <string.h>

#define BLOCK_SIZE_64 8
#define BLOCK_SIZE_128 16

// XOR two blocks
void xor_block(uint8_t *a, uint8_t *b, uint8_t *out, int len) {
    for (int i = 0; i < len; i++) {
        out[i] = a[i] ^ b[i];
    }
}

// Left shift a block by 1 bit
// Returns the bit shifted out of the most significant byte (carry)
uint8_t left_shift_one_bit(uint8_t *input, uint8_t *output, int len) {
    uint8_t overflow = 0;
    for (int i = len - 1; i >= 0; i--) {
        uint8_t new_overflow = (input[i] & 0x80) ? 1 : 0;
        output[i] = (input[i] << 1) | overflow;
        overflow = new_overflow;
    }
    return overflow;
}

// Generate subkey (K1 or K2) from input block
void generate_subkey(uint8_t *input, uint8_t *subkey, int len, uint8_t rb) {
    uint8_t shifted[len];
    uint8_t carry = left_shift_one_bit(input, shifted, len);

    if (carry) {
        // XOR with Rb at the last byte
        shifted[len - 1] ^= rb;
    }
    memcpy(subkey, shifted, len);
}

// Dummy block cipher encrypt function (for example only, returns all zeros)
void block_cipher_encrypt(uint8_t *key, uint8_t *input, uint8_t *output, int len) {
    // For real implementation, use AES or other cipher
    // Here we simulate by zero block for demonstration
    memset(output, 0, len);
}

void print_block(const char *label, uint8_t *block, int len) {
    printf("%s: ", label);
    for (int i = 0; i < len; i++) {
        printf("%02X ", block[i]);
    }
    printf("\n");
}

int main() {
    // Example using 128-bit block size (16 bytes)
    int block_size = BLOCK_SIZE_128;
    uint8_t Rb_128 = 0x87;
    uint8_t key[16] = {0};   // dummy key for encryption
    uint8_t zero_block[16] = {0};
    uint8_t L[16];
    uint8_t K1[16], K2[16];

    // Step 1: Encrypt zero block with key -> L
    block_cipher_encrypt(key, zero_block, L, block_size);

    // Step 2: Generate K1 from L
    generate_subkey(L, K1, block_size, Rb_128);

    // Step 3: Generate K2 from K1
    generate_subkey(K1, K2, block_size, Rb_128);

    // Output
    print_block("L  (Encrypted Zero Block)", L, block_size);
    print_block("K1 (First Subkey)", K1, block_size);
    print_block("K2 (Second Subkey)", K2, block_size);

    return 0;
}

program-32. Write a C program for DSA, because the value of k is generated for each signature, even if the same
message is signed twice on different occasions, the signatures will differ. This is not true of RSA
signatures. Write a C program for implication of this difference?

code:-
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Simulated hash function (sum of characters modulo)
int hash_message(const char* msg, int mod) {
    int hash = 0;
    for (int i = 0; msg[i] != '\0'; i++)
        hash = (hash + msg[i]) % mod;
    return hash;
}

// Modular exponentiation: (base^exp) % mod
int modexp(int base, int exp, int mod) {
    long long res = 1;
    long long b = base;
    while (exp > 0) {
        if (exp % 2 == 1)
            res = (res * b) % mod;
        b = (b * b) % mod;
        exp /= 2;
    }
    return (int)res;
}

// Simulated DSA signature: (r = g^k mod p mod q, s = (hash + x*r)/k mod q)
void dsa_sign(const char* msg, int p, int q, int g, int x, int k, int* r, int* s) {
    int h = hash_message(msg, q);
    *r = modexp(g, k, p) % q;
    *s = (h + x * (*r)) / k % q; // simplified for demo
}

// Simulated RSA signature: s = hash^d mod n
int rsa_sign(const char* msg, int d, int n) {
    int h = hash_message(msg, n);
    return modexp(h, d, n);
}

int main() {
    srand(time(NULL));

    const char* msg = "HelloWorld";

    // DSA simplified parameters
    int p = 23, q = 11, g = 4;
    int x = 5; // private key

    // Two different random k values
    int k1 = 3 + rand() % (q - 3);
    int k2 = 3 + rand() % (q - 3);

    int r1, s1, r2, s2;
    dsa_sign(msg, p, q, g, x, k1, &r1, &s1);
    dsa_sign(msg, p, q, g, x, k2, &r2, &s2);

    printf("DSA Signatures (same message):\n");
    printf("Signature 1: r = %d, s = %d (k = %d)\n", r1, s1, k1);
    printf("Signature 2: r = %d, s = %d (k = %d)\n", r2, s2, k2);

    // RSA simulated
    int d = 7, n = 33;
    int rsa1 = rsa_sign(msg, d, n);
    int rsa2 = rsa_sign(msg, d, n);

    printf("\nRSA Signatures (same message):\n");
    printf("Signature 1: %d\n", rsa1);
    printf("Signature 2: %d\n", rsa2);

    printf("\nConclusion:\n");
    if (rsa1 == rsa2)
        printf("- RSA signatures are identical (deterministic).\n");
    if (r1 != r2 || s1 != s2)
        printf("- DSA signatures differ (due to random k).\n");

    return 0;
}
program-33. Write a C program for Data encryption standard (DES) has been found vulnerable to very powerful
attacks and therefore, the popularity of DES has been found slightly on the decline. DES is a block
cipher and encrypts data in blocks of size of 64 bits each, which means 64 bits of plain text go as the
input to DES, which produces 64 bits of ciphertext. The same algorithm and key are used for
encryption and decryption, with minor differences. The key length is 56 bits. Implement in C
programming.

code:-
  #include <stdio.h>
#include <string.h>
#include <stdint.h>

// Initial permutation table
int IP[] = {
  58,50,42,34,26,18,10,2,
  60,52,44,36,28,20,12,4,
  62,54,46,38,30,22,14,6,
  64,56,48,40,32,24,16,8,
  57,49,41,33,25,17,9,1,
  59,51,43,35,27,19,11,3,
  61,53,45,37,29,21,13,5,
  63,55,47,39,31,23,15,7
};

// Final permutation table
int FP[] = {
  40,8,48,16,56,24,64,32,
  39,7,47,15,55,23,63,31,
  38,6,46,14,54,22,62,30,
  37,5,45,13,53,21,61,29,
  36,4,44,12,52,20,60,28,
  35,3,43,11,51,19,59,27,
  34,2,42,10,50,18,58,26,
  33,1,41,9,49,17,57,25
};

// Simplified XOR-based round function for demo
uint32_t feistel(uint32_t half, uint64_t key) {
    return (half ^ (uint32_t)(key & 0xFFFFFFFF));
}

// Permutation function
uint64_t permute(uint64_t input, int* table, int n) {
    uint64_t output = 0;
    for (int i = 0; i < n; i++) {
        output <<= 1;
        output |= (input >> (64 - table[i])) & 0x1;
    }
    return output;
}

// Encrypt function using 16 Feistel rounds
uint64_t des_encrypt(uint64_t plaintext, uint64_t key) {
    uint64_t permuted_input = permute(plaintext, IP, 64);

    uint32_t left = permuted_input >> 32;
    uint32_t right = permuted_input & 0xFFFFFFFF;

    for (int round = 0; round < 16; round++) {
        uint32_t temp = right;
        right = left ^ feistel(right, key);  // simplified round
        left = temp;
    }

    uint64_t combined = ((uint64_t)right << 32) | left;
    return permute(combined, FP, 64);
}

// Decrypt is same as encrypt due to symmetric nature with same key
uint64_t des_decrypt(uint64_t ciphertext, uint64_t key) {
    return des_encrypt(ciphertext, key); // since feistel structure is symmetric
}

int main() {
    uint64_t plaintext = 0x0123456789ABCDEF;
    uint64_t key = 0x133457799BBCDFF1;  // Only 56 bits used

    printf("Plaintext:  0x%016llX\n", plaintext);

    uint64_t ciphertext = des_encrypt(plaintext, key);
    printf("Encrypted:  0x%016llX\n", ciphertext);

    uint64_t decrypted = des_decrypt(ciphertext, key);
    printf("Decrypted:  0x%016llX\n", decrypted);

    return 0;
}
program-34. Write a C program for ECB, CBC, and CFB modes, the plaintext must be a sequence of one or more
complete data blocks (or, for CFB mode, data segments). In other words, for these three modes, the total
number of bits in the plaintext must be a positive multiple of the block (or segment) size. One common
method of padding, if needed, consists of a 1 bit followed by as few zero bits, possibly none, as are
necessary to complete the final block. It is considered good practice for the sender to pad every message,
including messages in which the final message block is already complete. What is the motivation for
including a padding block when padding is not needed?
code:-
  #include <stdio.h>
#include <string.h>

// Pseudocode for AES in ECB, CBC, CFB
// In real C, you'd use OpenSSL or libsodium

int main() {
    char *plaintext = "Hello, this is a 32-byte message.";
    char padded[64] = {0};

    // 1. Padding: 1 bit followed by 0s
    strcpy(padded, plaintext);
    int len = strlen(plaintext);
    padded[len] = 0x80;  // Add 1-bit (in hex)

    // 2. Encrypt with ECB
    printf("Encrypt with ECB Mode...\n");
    // ECB_Encrypt(padded);

    // 3. Encrypt with CBC
    printf("Encrypt with CBC Mode...\n");
    // CBC_Encrypt(padded, IV);

    // 4. Encrypt with CFB (no padding needed)
    printf("Encrypt with CFB Mode...\n");
    // CFB_Encrypt(plaintext, IV);

    return 0;
}

program:-35. Write a C program for one-time pad version of the Vigenère cipher. In this scheme, the key is a
stream of random numbers between 0 and 26. For example, if the key is 3 19 5 . . . , then the first letter of
plaintext is encrypted with a shift of 3 letters, the second with a shift of 19 letters, the third with a shift of
5 letters, and so on.
  code:-
      #include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define MAX_LEN 100

void encrypt(char *plaintext, int *key, char *ciphertext) {
    for (int i = 0; plaintext[i] != '\0'; i++) {
        if (plaintext[i] >= 'A' && plaintext[i] <= 'Z') {
            ciphertext[i] = ((plaintext[i] - 'A') + key[i]) % 26 + 'A';
        } else if (plaintext[i] >= 'a' && plaintext[i] <= 'z') {
            ciphertext[i] = ((plaintext[i] - 'a') + key[i]) % 26 + 'a';
        } else {
            ciphertext[i] = plaintext[i]; // non-alpha stays the same
        }
    }
}

void decrypt(char *ciphertext, int *key, char *plaintext) {
    for (int i = 0; ciphertext[i] != '\0'; i++) {
        if (ciphertext[i] >= 'A' && ciphertext[i] <= 'Z') {
            plaintext[i] = ((ciphertext[i] - 'A') - key[i] + 26) % 26 + 'A';
        } else if (ciphertext[i] >= 'a' && ciphertext[i] <= 'z') {
            plaintext[i] = ((ciphertext[i] - 'a') - key[i] + 26) % 26 + 'a';
        } else {
            plaintext[i] = ciphertext[i]; // non-alpha stays the same
        }
    }
}

void generateKey(int *key, int length) {
    for (int i = 0; i < length; i++) {
        key[i] = rand() % 27; // key between 0 to 26 inclusive
    }
}

int main() {
    char plaintext[MAX_LEN], ciphertext[MAX_LEN] = {0}, decrypted[MAX_LEN] = {0};
    int key[MAX_LEN];

    printf("Enter plaintext: ");
    fgets(plaintext, MAX_LEN, stdin);
    plaintext[strcspn(plaintext, "\n")] = 0;  // Remove trailing newline

    int len = strlen(plaintext);
    srand(time(0));
    generateKey(key, len);

    // Display random key
    printf("Random key: ");
    for (int i = 0; i < len; i++) {
        printf("%d ", key[i]);
    }
    printf("\n");

    encrypt(plaintext, key, ciphertext);
    printf("Encrypted text: %s\n", ciphertext);

    decrypt(ciphertext, key, decrypted);
    printf("Decrypted text: %s\n", decrypted);

    return 0;
}

program:-36. Write a C program for Caesar cipher, known as the affine Caesar cipher, has the following form: For
each plaintext letter p, substitute the ciphertext letter C: C = E([a, b], p) = (ap + b) mod 26 A basic
requirement of any encryption algorithm is that it be one-to-one. That is, if p q, then E(k, p) E(k, q).
Otherwise, decryption is impossible, because more than one plaintext character maps into the same
ciphertext character. The affine Caesar cipher is not one-to-one for all values of a. For example, for a = 2
and b = 3, then E([a, b], 0) = E([a, b], 13) = 3.
 code:- 
    #include <stdio.h>

// Function to find gcd of two numbers
int gcd(int a, int b) {
    while (b != 0) {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}

// Function to find modular inverse of a mod m using Extended Euclidean Algorithm
int modInverse(int a, int m) {
    int m0 = m, t, q;
    int x0 = 0, x1 = 1;

    if (m == 1)
        return 0;

    while (a > 1) {
        q = a / m;
        t = m;

        m = a % m;
        a = t;
        t = x0;

        x0 = x1 - q * x0;
        x1 = t;
    }

    if (x1 < 0)
        x1 += m0;

    return x1;
}

void encrypt(char *plaintext, int a, int b, char *ciphertext) {
    for (int i = 0; plaintext[i] != '\0'; i++) {
        char p = plaintext[i];
        if (p >= 'A' && p <= 'Z') {
            ciphertext[i] = ((a * (p - 'A') + b) % 26) + 'A';
        } else if (p >= 'a' && p <= 'z') {
            ciphertext[i] = ((a * (p - 'a') + b) % 26) + 'a';
        } else {
            ciphertext[i] = p; // Non-alpha characters unchanged
        }
    }
}

void decrypt(char *ciphertext, int a, int b, char *plaintext) {
    int a_inv = modInverse(a, 26);
    for (int i = 0; ciphertext[i] != '\0'; i++) {
        char c = ciphertext[i];
        if (c >= 'A' && c <= 'Z') {
            plaintext[i] = ((a_inv * ((c - 'A') - b + 26)) % 26) + 'A';
        } else if (c >= 'a' && c <= 'z') {
            plaintext[i] = ((a_inv * ((c - 'a') - b + 26)) % 26) + 'a';
        } else {
            plaintext[i] = c; // Non-alpha unchanged
        }
    }
}

int main() {
    char plaintext[100], ciphertext[100], decrypted[100];
    int a, b;

    printf("Enter plaintext: ");
    fgets(plaintext, sizeof(plaintext), stdin);

    // Remove newline
    int len = 0;
    while (plaintext[len] != '\0') {
        if (plaintext[len] == '\n') {
            plaintext[len] = '\0';
            break;
        }
        len++;
    }

    do {
        printf("Enter key a (must be coprime with 26): ");
        scanf("%d", &a);
        if (gcd(a, 26) != 1)
            printf("Invalid key 'a'. It must be coprime with 26.\n");
    } while (gcd(a, 26) != 1);

    printf("Enter key b (0-25): ");
    scanf("%d", &b);
    b = b % 26;

    encrypt(plaintext, a, b, ciphertext);
    ciphertext[len] = '\0';

    printf("Encrypted text: %s\n", ciphertext);

    decrypt(ciphertext, a, b, decrypted);
    decrypted[len] = '\0';

    printf("Decrypted text: %s\n", decrypted);

    return 0;
}
program:-37. Write a C program that can perform a letter frequency attack on any monoalphabetic substitution
cipher without human intervention. Your software should produce possible plaintexts in rough order of
likelihood. It would be good if your user interface allowed the user to specify “give me the top 10
possible plaintexts.”
  code;-
    #include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#define ALPHABET_SIZE 26

// English letter frequency order (most to least common)
const char english_freq_order[ALPHABET_SIZE + 1] = "ETAOINSHRDLCUMWFGYPBVKJXQZ";

// Structure to hold letter frequency
typedef struct {
    char letter;
    int count;
} LetterFreq;

// Compare function for qsort (descending order)
int compare_freq(const void *a, const void *b) {
    LetterFreq *la = (LetterFreq*)a;
    LetterFreq *lb = (LetterFreq*)b;
    return lb->count - la->count;
}

// Simple mapping from ciphertext freq to English freq
void frequency_attack(const char *ciphertext, char *plaintext) {
    int freq[ALPHABET_SIZE] = {0};
    int len = strlen(ciphertext);

    // Count letter frequencies in ciphertext
    for (int i = 0; i < len; i++) {
        char c = toupper(ciphertext[i]);
        if (c >= 'A' && c <= 'Z') {
            freq[c - 'A']++;
        }
    }

    // Create array of LetterFreq structs
    LetterFreq cipher_freq[ALPHABET_SIZE];
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        cipher_freq[i].letter = 'A' + i;
        cipher_freq[i].count = freq[i];
    }

    // Sort ciphertext letters by frequency descending
    qsort(cipher_freq, ALPHABET_SIZE, sizeof(LetterFreq), compare_freq);

    // Map cipher letter -> English letter according to freq rank
    char mapping[ALPHABET_SIZE];
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        mapping[cipher_freq[i].letter - 'A'] = english_freq_order[i];
    }

    // Decrypt using mapping
    for (int i = 0; i < len; i++) {
        char c = ciphertext[i];
        if (isalpha(c)) {
            int idx = toupper(c) - 'A';
            char p = mapping[idx];
            // Preserve case
            plaintext[i] = (isupper(c)) ? p : tolower(p);
        } else {
            plaintext[i] = c; // non-alpha unchanged
        }
    }
    plaintext[len] = '\0';
}

int main() {
    char ciphertext[1000];
    int top_n;

    printf("Enter ciphertext: ");
    fgets(ciphertext, sizeof(ciphertext), stdin);
    // Remove trailing newline if present
    size_t len = strlen(ciphertext);
    if (len > 0 && ciphertext[len-1] == '\n')
        ciphertext[len-1] = '\0';

    printf("Enter how many possible plaintexts you want (currently supports only 1): ");
    scanf("%d", &top_n);

    if (top_n != 1) {
        printf("Sorry, this simple program currently supports only 1 plaintext output.\n");
        top_n = 1;
    }

    char plaintext[1000];
    frequency_attack(ciphertext, plaintext);

    printf("\nPossible plaintext:\n%s\n", plaintext);

    return 0;
}
program :38. Write a C program for Hill cipher succumbs to a known plaintext attack if sufficient plaintext–
ciphertext pairs are provided. It is even easier to solve the Hill cipher if a chosen plaintext attack can be
mounted. Implement in C programming.

     CODE : 
#include <stdio.h>
#include <stdlib.h>

#define MOD 26

// Function to find modular inverse of a number modulo 26
int modInverse(int a, int m) {
    a = a % m;
    for (int x = 1; x < m; x++)
        if ((a * x) % m == 1)
            return x;
    return -1; // No modular inverse exists
}

// Compute determinant of 2x2 matrix mod 26
int determinant(int matrix[2][2]) {
    int det = (matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]) % MOD;
    if (det < 0) det += MOD;
    return det;
}

// Compute inverse of 2x2 matrix mod 26
int invertMatrix(int matrix[2][2], int invMatrix[2][2]) {
    int det = determinant(matrix);
    int detInv = modInverse(det, MOD);
    if (detInv == -1) {
        printf("Matrix not invertible mod %d\n", MOD);
        return 0; // Inverse doesn't exist
    }

    // Compute adjugate matrix
    invMatrix[0][0] = matrix[1][1];
    invMatrix[0][1] = -matrix[0][1];
    invMatrix[1][0] = -matrix[1][0];
    invMatrix[1][1] = matrix[0][0];

    // Modulo operations
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++) {
            invMatrix[i][j] = (invMatrix[i][j] * detInv) % MOD;
            if (invMatrix[i][j] < 0) invMatrix[i][j] += MOD;
        }

    return 1; // Success
}

// Multiply 2x2 matrix by 2x2 matrix mod 26
void multiplyMatrices(int A[2][2], int B[2][2], int result[2][2]) {
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++) {
            result[i][j] = 0;
            for (int k = 0; k < 2; k++) {
                result[i][j] += A[i][k] * B[k][j];
            }
            result[i][j] %= MOD;
        }
}

// Convert character 'A' - 'Z' to number 0 - 25
int charToInt(char c) {
    return c - 'A';
}

int main() {
    char plaintext[5], ciphertext[5];
    int P[2][2], C[2][2];
    int P_inv[2][2], K[2][2];

    printf("Enter 4 letters of known plaintext (2 blocks of 2 letters): ");
    scanf("%4s", plaintext);
    printf("Enter corresponding 4 letters of ciphertext: ");
    scanf("%4s", ciphertext);

    // Convert plaintext and ciphertext into 2x2 matrices
    for (int i = 0; i < 4; i++) {
        P[i / 2][i % 2] = charToInt(plaintext[i]);
        C[i / 2][i % 2] = charToInt(ciphertext[i]);
    }

    // Invert plaintext matrix
    if (!invertMatrix(P, P_inv)) {
        printf("Cannot recover key as plaintext matrix is not invertible.\n");
        return 1;
    }

    // Compute key matrix: K = C * P_inv mod 26
    multiplyMatrices(C, P_inv, K);

    printf("Recovered key matrix K:\n");
    for (int i = 0; i < 2; i++) {
        printf("%d %d\n", K[i][0], K[i][1]);
    }

    return 0;
}

Program : 39. Write a C program that can perform a letter frequency attack on an additive cipher without human
intervention. Your software should produce possible plaintexts in rough order of likelihood. It would be
good if your user interface allowed the user to specify “give me the top 10 possible plaintexts.”

   CODE : 

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define ALPHABET_SIZE 26
#define MAX_TEXT_LENGTH 1000

double english_freq[ALPHABET_SIZE] = {
    8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1,
    7.0, 0.15, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9,
    0.1, 6.0, 6.3, 9.1, 2.8, 1.0, 2.4, 0.15,
    2.0, 0.07
};

typedef struct {
    int key;
    double score;
    char plaintext[MAX_TEXT_LENGTH];
} DecryptionResult;

void decrypt(char *ciphertext, char *plaintext, int key) {
    int len = strlen(ciphertext);
    for (int i = 0; i < len; i++) {
        if (ciphertext[i] >= 'A' && ciphertext[i] <= 'Z') {
            plaintext[i] = ((ciphertext[i] - 'A' - key + ALPHABET_SIZE) % ALPHABET_SIZE) + 'A';
        } else {
            plaintext[i] = ciphertext[i]; // keep non-alpha as is
        }
    }
    plaintext[len] = '\0';
}


double frequency_score(char *text) {
    int freq[ALPHABET_SIZE] = {0};
    int len = strlen(text);
    if (len == 0) return 0.0;

    for (int i = 0; i < len; i++) {
        if (text[i] >= 'A' && text[i] <= 'Z') {
            freq[text[i] - 'A']++;
        }
    }

    double score = 0.0;
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        double text_freq = (double)freq[i] / len * 100;
        // Smaller difference means higher score, so invert difference
        double diff = text_freq - english_freq[i];
        if (diff < 0) diff = -diff;
        score += (100 - diff); // the closer to English freq, the higher
    }
    return score;
}

int compare_results(const void *a, const void *b) {
    DecryptionResult *r1 = (DecryptionResult*)a;
    DecryptionResult *r2 = (DecryptionResult*)b;
    if (r2->score > r1->score) return 1;
    else if (r2->score < r1->score) return -1;
    else return 0;
}

int main() {
    char ciphertext[MAX_TEXT_LENGTH];
    int topN;

    printf("Enter ciphertext (uppercase letters only): ");
    fgets(ciphertext, MAX_TEXT_LENGTH, stdin);
    ciphertext[strcspn(ciphertext, "\n")] = 0;

    printf("Enter number of top possible plaintexts to display: ");
    scanf("%d", &topN);
    if (topN > ALPHABET_SIZE) topN = ALPHABET_SIZE;

    DecryptionResult results[ALPHABET_SIZE];
    for (int key = 0; key < ALPHABET_SIZE; key++) {
        decrypt(ciphertext, results[key].plaintext, key);
        results[key].key = key;
        results[key].score = frequency_score(results[key].plaintext);
    }

    qsort(results, ALPHABET_SIZE, sizeof(DecryptionResult), compare_results);

    printf("\nTop %d possible plaintexts (key = shift):\n", topN);
    for (int i = 0; i < topN; i++) {
        printf("Key %2d: %s  (Score: %.2f)\n", results[i].key, results[i].plaintext, results[i].score);
    }

    return 0;
}
 
Program : 40. Write a C program that can perform a letter frequency attack on any monoalphabetic substitution
cipher without human intervention. Your software should produce possible plaintexts in rough order of
likelihood. It would be good if your user interface allowed the user to specify “give me the top 10
possible plaintexts.”

CODE : 

 #include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ALPHABET_SIZE 26
#define MAX_TEXT_LENGTH 1000
#define TOP_RESULTS 10


const char english_freq_order[ALPHABET_SIZE] = {
    'E', 'T', 'A', 'O', 'I', 'N', 'S', 'H', 'R', 'D',
    'L', 'C', 'U', 'M', 'W', 'F', 'G', 'Y', 'P', 'B',
    'V', 'K', 'J', 'X', 'Q', 'Z'
};

typedef struct {
    char letter;
    int freq;
} LetterFreq;

typedef struct {
    char plaintext[MAX_TEXT_LENGTH];
    int score; 
} Result;

void count_frequencies(const char *text, LetterFreq freq[ALPHABET_SIZE]) {
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        freq[i].letter = 'A' + i;
        freq[i].freq = 0;
    }
    int len = strlen(text);
    for (int i = 0; i < len; i++) {
        char c = text[i];
        if (c >= 'A' && c <= 'Z') {
            freq[c - 'A'].freq++;
        }
    }
}

int freq_cmp(const void *a, const void *b) {
    LetterFreq *f1 = (LetterFreq*)a;
    LetterFreq *f2 = (LetterFreq*)b;
    return f2->freq - f1->freq;
}

void apply_mapping(const char *ciphertext, char *plaintext, char mapping[ALPHABET_SIZE]) {
    int len = strlen(ciphertext);
    for (int i = 0; i < len; i++) {
        char c = ciphertext[i];
        if (c >= 'A' && c <= 'Z') {
            plaintext[i] = mapping[c - 'A'];
        } else {
            plaintext[i] = c; // keep as is
        }
    }
    plaintext[len] = '\0';
}

int score_plaintext(const char *plaintext) {
    int score = 0;
    int len = strlen(plaintext);
    for (int i = 0; i < len; i++) {
        char c = plaintext[i];
        if (!(c >= 'A' && c <= 'Z')) {
            score += 1; // penalty for non-alpha (could be improved)
        }
    }
    return score;
}

void swap_chars(char *mapping, char a, char b) {
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        if (mapping[i] == a) mapping[i] = b;
        else if (mapping[i] == b) mapping[i] = a;
    }
}

int main() {
    char ciphertext[MAX_TEXT_LENGTH];
    printf("Enter ciphertext (uppercase letters only): ");
    fgets(ciphertext, MAX_TEXT_LENGTH, stdin);
    ciphertext[strcspn(ciphertext, "\n")] = 0; // remove newline

    LetterFreq freq[ALPHABET_SIZE];
    count_frequencies(ciphertext, freq);
    qsort(freq, ALPHABET_SIZE, sizeof(LetterFreq), freq_cmp);

    char mapping[ALPHABET_SIZE];
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        mapping[freq[i].letter - 'A'] = english_freq_order[i];
    }

    Result results[TOP_RESULTS];

    apply_mapping(ciphertext, results[0].plaintext, mapping);
    results[0].score = score_plaintext(results[0].plaintext);

    int generated = 1;
    for (int i = 0; i < 5 && generated < TOP_RESULTS; i++) {
        for (int j = i+1; j < 6 && generated < TOP_RESULTS; j++) {
            char temp_mapping[ALPHABET_SIZE];
            memcpy(temp_mapping, mapping, ALPHABET_SIZE);
            swap_chars(temp_mapping, english_freq_order[i], english_freq_order[j]);

            apply_mapping(ciphertext, results[generated].plaintext, temp_mapping);
            results[generated].score = score_plaintext(results[generated].plaintext);
            generated++;
        }
    }

    int cmp_results(const void *a, const void *b) {
        Result *r1 = (Result*)a;
        Result *r2 = (Result*)b;
        return r1->score - r2->score;
    }
    qsort(results, generated, sizeof(Result), cmp_results);

    printf("\nTop %d possible plaintexts:\n", generated);
    for (int i = 0; i < generated; i++) {
        printf("Candidate %d (score=%d): %s\n", i+1, results[i].score, results[i].plaintext);
    }

    return 0;
}


 




